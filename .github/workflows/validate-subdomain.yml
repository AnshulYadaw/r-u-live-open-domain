name: ğŸ” Validate Subdomain Request

on:
  pull_request:
    types: [opened, synchronize, reopened]
    paths:
      - 'subdomains/*.yaml'

jobs:
  validate:
    runs-on: ubuntu-latest
    
    steps:
    - name: ğŸ“¥ Checkout Repository
      uses: actions/checkout@v4

    - name: ğŸ Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'

    - name: ğŸ“¦ Install Dependencies
      run: |
        pip install --upgrade pip
        pip install pyyaml jsonschema requests

    - name: ğŸ” Get Changed Files
      id: changed-files
      uses: tj-actions/changed-files@v41
      with:
        files: subdomains/*.yaml

    - name: âœ… Validate Subdomain Files
      run: |
        python << 'EOF'
        import os, yaml, requests, glob, re, sys
        from jsonschema import validate, ValidationError

        # Define schema for validation
        schema = {
            "type": "object",
            "properties": {
                "subdomain": {
                    "type": "string",
                    "pattern": "^[a-zA-Z0-9]([a-zA-Z0-9-]{1,61}[a-zA-Z0-9])?$"
                },
                "owner": {
                    "type": "object",
                    "properties": {
                        "name": {"type": "string", "minLength": 1},
                        "email": {"type": "string", "pattern": "^[^@]+@[^@]+\\.[^@]+$"}
                    },
                    "required": ["name", "email"]
                },
                "record": {
                    "type": "object",
                    "oneOf": [
                        {"properties": {"A": {"type": "string"}}, "required": ["A"]},
                        {"properties": {"CNAME": {"type": "string"}}, "required": ["CNAME"]}
                    ]
                }
            },
            "required": ["subdomain", "owner", "record"]
        }

        def validate_ip(ip):
            """Validate IPv4 address"""
            try:
                parts = ip.split('.')
                return len(parts) == 4 and all(0 <= int(part) <= 255 for part in parts)
            except:
                return False

        def validate_domain(domain):
            """Validate domain name"""
            if len(domain) > 253 or len(domain) < 3:
                return False
            pattern = re.compile(r'^[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$')
            return pattern.match(domain) is not None

        def is_subdomain_available(subdomain):
            """Check if subdomain is available by testing DNS resolution"""
            try:
                import socket
                socket.gethostbyname(f"{subdomain}.r-u.live")
                return False  # Already exists
            except socket.gaierror:
                return True  # Available

        errors = []
        warnings = []
        success = []
        existing_subdomains = set()

        # Check all existing subdomains
        all_files = glob.glob("subdomains/*.yaml")
        for file in all_files:
            try:
                with open(file, 'r') as f:
                    data = yaml.safe_load(f)
                if 'subdomain' in data:
                    existing_subdomains.add(data['subdomain'])
            except:
                pass

        # Get changed files from environment
        changed_files = "${{ steps.changed-files.outputs.all_changed_files }}".split()
        
        if not changed_files or changed_files == ['']:
            print("â„¹ï¸  No subdomain files changed.")
            exit(0)

        print(f"ğŸ” Validating {len(changed_files)} changed file(s)...")

        for file in changed_files:
            if not file.endswith('.yaml'):
                continue
                
            print(f"\nğŸ“„ Checking: {file}")
            
            try:
                with open(file, 'r') as f:
                    content = f.read()
                    if not content.strip():
                        errors.append(f"âŒ {file}: File is empty")
                        continue
                    
                    data = yaml.safe_load(content)
                
                if not data:
                    errors.append(f"âŒ {file}: No data found")
                    continue
                
                # Validate against schema
                try:
                    validate(data, schema)
                except ValidationError as e:
                    errors.append(f"âŒ {file}: {e.message}")
                    continue
                
                subdomain = data["subdomain"]
                record_type = list(data["record"].keys())[0]
                record_value = data["record"][record_type]
                
                # Check subdomain format and length
                if len(subdomain) < 3:
                    errors.append(f"âŒ {file}: Subdomain '{subdomain}' too short (minimum 3 characters)")
                elif len(subdomain) > 63:
                    errors.append(f"âŒ {file}: Subdomain '{subdomain}' too long (maximum 63 characters)")
                
                # Check for existing subdomains
                other_files = [f for f in all_files if f != file]
                for other_file in other_files:
                    try:
                        with open(other_file, 'r') as f:
                            other_data = yaml.safe_load(f)
                        if other_data and other_data.get('subdomain') == subdomain:
                            errors.append(f"âŒ {file}: Subdomain '{subdomain}' already exists in {other_file}")
                    except:
                        pass
                
                # Validate record value
                if record_type == "A":
                    if not validate_ip(record_value):
                        errors.append(f"âŒ {file}: Invalid IP address '{record_value}'")
                    elif record_value.startswith('192.168.') or record_value.startswith('10.') or record_value.startswith('172.'):
                        warnings.append(f"âš ï¸  {file}: Private IP address '{record_value}' detected")
                elif record_type == "CNAME":
                    if not validate_domain(record_value):
                        errors.append(f"âŒ {file}: Invalid domain '{record_value}'")
                    elif record_value.endswith('.r-u.live'):
                        errors.append(f"âŒ {file}: Cannot point to another r-u.live subdomain")
                
                # Check reserved subdomains
                reserved = ["www", "mail", "ftp", "admin", "api", "app", "blog", "shop", "store", "test", "dev", "staging", "prod", "production"]
                if subdomain.lower() in reserved:
                    errors.append(f"âŒ {file}: Subdomain '{subdomain}' is reserved")
                
                # Check for inappropriate content
                inappropriate = ["spam", "hack", "phish", "scam", "fake", "virus", "malware"]
                if any(word in subdomain.lower() for word in inappropriate):
                    errors.append(f"âŒ {file}: Subdomain '{subdomain}' contains inappropriate content")
                
                # Validate email format
                email = data["owner"]["email"]
                if not re.match(r'^[^@]+@[^@]+\.[^@]+$', email):
                    errors.append(f"âŒ {file}: Invalid email format '{email}'")
                
                if not errors:
                    success.append(f"âœ… {file}: {subdomain}.r-u.live â†’ {record_value} ({record_type})")
                
            except yaml.YAMLError as e:
                errors.append(f"âŒ {file}: YAML parsing error - {str(e)}")
            except FileNotFoundError:
                errors.append(f"âŒ {file}: File not found")
            except Exception as e:
                errors.append(f"âŒ {file}: Unexpected error - {str(e)}")

        # Print results
        if success:
            print(f"\nâœ… VALIDATION PASSED:")
            for msg in success:
                print(f"   {msg}")

        if warnings:
            print(f"\nâš ï¸  WARNINGS:")
            for warning in warnings:
                print(f"   {warning}")

        if errors:
            print(f"\nâŒ VALIDATION ERRORS:")
            for error in errors:
                print(f"   {error}")
            print(f"\nğŸ’¡ Please fix the errors above before merging.")
            sys.exit(1)
        else:
            print(f"\nğŸ‰ All validations passed! Ready to merge.")
        EOF

    - name: ğŸ’¬ Comment on PR
      if: always()
      uses: actions/github-script@v7
      with:
        script: |
          const fs = require('fs');
          const yaml = require('js-yaml');
          
          // Get changed files
          const changedFiles = '${{ steps.changed-files.outputs.all_changed_files }}';
          const files = changedFiles.split(' ').filter(f => f.endsWith('.yaml') && f);
          
          if (files.length === 0) return;
          
          let comment = '## ğŸ” Subdomain Validation Results\n\n';
          
          // Check if validation passed
          const workflow = '${{ job.status }}';
          
          if (workflow === 'success') {
            comment += 'âœ… **All validations passed!** Your subdomain request is ready for review.\n\n';
            
            comment += '### ğŸ“‹ Requested Subdomains:\n\n';
            comment += '| Subdomain | Target | Type | Owner |\n';
            comment += '|-----------|--------|------|-------|\n';
            
            for (const file of files) {
              try {
                if (fs.existsSync(file)) {
                  const content = fs.readFileSync(file, 'utf8');
                  const data = yaml.load(content);
                  const subdomain = data.subdomain;
                  const recordType = Object.keys(data.record)[0];
                  const target = data.record[recordType];
                  const owner = data.owner.name;
                  
                  comment += `| \`${subdomain}.r-u.live\` | \`${target}\` | ${recordType} | ${owner} |\n`;
                }
              } catch (error) {
                console.error(`Error reading ${file}:`, error);
              }
            }
            
            comment += '\n### âš¡ What happens next?\n';
            comment += '1. A maintainer will review your request\n';
            comment += '2. Once approved and merged, DNS records will be created automatically\n';
            comment += '3. Your subdomain will be active within 5-10 minutes\n';
            comment += '4. You\'ll receive a confirmation comment with setup instructions\n\n';
            comment += 'ğŸ“§ **For questions:** Mention @anshulyadaw in a comment.';
            
          } else {
            comment += 'âŒ **Validation failed!** Please fix the issues below and update your PR.\n\n';
            comment += '### ğŸ”§ Common fixes:\n';
            comment += '- Check YAML syntax and indentation\n';
            comment += '- Ensure subdomain follows naming rules (3-63 chars, alphanumeric + hyphens)\n';
            comment += '- Verify IP address or domain format\n';
            comment += '- Use a valid email address\n';
            comment += '- Avoid reserved names (www, api, admin, etc.)\n\n';
            comment += 'ğŸ“– **Need help?** Check the [README](README.md) for examples or mention @anshulyadaw.';
          }
          
          github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: comment
          });
