name: üöÄ Automated DNS Management via Cloudflare

on:
  pull_request:
    types: [closed]
    branches: [main]
  workflow_dispatch:
    inputs:
      force_update:
        description: 'Force update all DNS records'
        required: false
        default: false
        type: boolean

jobs:
  validate-and-deploy:
    if: github.event.pull_request.merged == true || github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    
    steps:
    - name: üì• Checkout Repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: üêç Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'

    - name: üì¶ Install Dependencies
      run: |
        pip install --upgrade pip
        pip install pyyaml requests jsonschema

    - name: üîç Get Changed Files
      id: changed-files
      uses: tj-actions/changed-files@v41
      with:
        files: subdomains/*.yaml

    - name: ‚úÖ Validate YAML Files
      env:
        CF_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
        CF_ZONE_ID: ${{ secrets.CLOUDFLARE_ZONE_ID }}
      run: |
        python << 'EOF'
        import os, yaml, requests, glob, re, sys
        from jsonschema import validate, ValidationError

        # Define schema for validation
        schema = {
            "type": "object",
            "properties": {
                "subdomain": {
                    "type": "string",
                    "pattern": "^[a-zA-Z0-9]([a-zA-Z0-9-]{1,61}[a-zA-Z0-9])?$"
                },
                "owner": {
                    "type": "object",
                    "properties": {
                        "name": {"type": "string", "minLength": 1},
                        "email": {"type": "string", "format": "email"}
                    },
                    "required": ["name", "email"]
                },
                "record": {
                    "type": "object",
                    "oneOf": [
                        {"properties": {"A": {"type": "string"}}, "required": ["A"]},
                        {"properties": {"CNAME": {"type": "string"}}, "required": ["CNAME"]}
                    ]
                }
            },
            "required": ["subdomain", "owner", "record"]
        }

        def validate_ip(ip):
            """Validate IPv4 address"""
            parts = ip.split('.')
            return len(parts) == 4 and all(0 <= int(part) <= 255 for part in parts if part.isdigit())

        def validate_domain(domain):
            """Validate domain name"""
            if len(domain) > 253:
                return False
            pattern = re.compile(r'^[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$')
            return pattern.match(domain) is not None

        def check_existing_dns(subdomain):
            """Check if DNS record already exists"""
            headers = {
                "Authorization": f"Bearer {os.environ['CF_API_TOKEN']}",
                "Content-Type": "application/json"
            }
            
            response = requests.get(
                f"https://api.cloudflare.com/client/v4/zones/{os.environ['CF_ZONE_ID']}/dns_records",
                headers=headers,
                params={"name": f"{subdomain}.r-u.live"}
            )
            
            if response.status_code == 200:
                return len(response.json().get('result', [])) > 0
            return False

        errors = []
        existing_subdomains = set()

        # Get all YAML files
        files = glob.glob("subdomains/*.yaml")
        
        for file in files:
            try:
                with open(file, 'r') as f:
                    data = yaml.safe_load(f)
                
                # Validate against schema
                validate(data, schema)
                
                subdomain = data["subdomain"]
                record_type = list(data["record"].keys())[0]
                record_value = data["record"][record_type]
                
                # Check for duplicate subdomains
                if subdomain in existing_subdomains:
                    errors.append(f"‚ùå Duplicate subdomain '{subdomain}' found in {file}")
                existing_subdomains.add(subdomain)
                
                # Validate record value
                if record_type == "A" and not validate_ip(record_value):
                    errors.append(f"‚ùå Invalid IP address '{record_value}' in {file}")
                elif record_type == "CNAME" and not validate_domain(record_value):
                    errors.append(f"‚ùå Invalid domain '{record_value}' in {file}")
                
                # Check reserved subdomains
                reserved = ["www", "mail", "ftp", "admin", "api", "app", "blog", "shop", "store"]
                if subdomain in reserved:
                    errors.append(f"‚ùå Subdomain '{subdomain}' is reserved in {file}")
                
                print(f"‚úÖ {file}: {subdomain}.r-u.live ‚Üí {record_value} ({record_type})")
                
            except ValidationError as e:
                errors.append(f"‚ùå Schema validation failed for {file}: {e.message}")
            except yaml.YAMLError as e:
                errors.append(f"‚ùå YAML parsing failed for {file}: {str(e)}")
            except Exception as e:
                errors.append(f"‚ùå Error processing {file}: {str(e)}")

        if errors:
            print("\nüö® VALIDATION ERRORS:")
            for error in errors:
                print(error)
            sys.exit(1)
        
        print(f"\n‚úÖ All {len(files)} subdomain files are valid!")
        EOF

    - name: üåê Deploy DNS Records
      env:
        CF_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
        CF_ZONE_ID: ${{ secrets.CLOUDFLARE_ZONE_ID }}
        FORCE_UPDATE: ${{ github.event.inputs.force_update }}
      run: |
        python << 'EOF'
        import os, yaml, requests, glob, json
        from datetime import datetime

        def create_or_update_dns_record(subdomain, record_type, record_value):
            """Create or update DNS record in Cloudflare"""
            headers = {
                "Authorization": f"Bearer {os.environ['CF_API_TOKEN']}",
                "Content-Type": "application/json"
            }
            
            zone_id = os.environ['CF_ZONE_ID']
            record_name = f"{subdomain}.r-u.live"
            
            # Check if record exists
            existing_response = requests.get(
                f"https://api.cloudflare.com/client/v4/zones/{zone_id}/dns_records",
                headers=headers,
                params={"name": record_name}
            )
            
            payload = {
                "type": record_type,
                "name": record_name,
                "content": record_value,
                "ttl": 3600,
                "proxied": False
            }
            
            if existing_response.status_code == 200:
                existing_records = existing_response.json().get('result', [])
                
                if existing_records:
                    # Update existing record
                    record_id = existing_records[0]['id']
                    response = requests.put(
                        f"https://api.cloudflare.com/client/v4/zones/{zone_id}/dns_records/{record_id}",
                        json=payload,
                        headers=headers
                    )
                    action = "UPDATED"
                else:
                    # Create new record
                    response = requests.post(
                        f"https://api.cloudflare.com/client/v4/zones/{zone_id}/dns_records",
                        json=payload,
                        headers=headers
                    )
                    action = "CREATED"
            else:
                # Create new record
                response = requests.post(
                    f"https://api.cloudflare.com/client/v4/zones/{zone_id}/dns_records",
                    json=payload,
                    headers=headers
                )
                action = "CREATED"
            
            return response, action

        print(f"üöÄ Starting DNS deployment at {datetime.now()}")
        
        files = glob.glob("subdomains/*.yaml")
        success_count = 0
        error_count = 0
        
        for file in files:
            try:
                with open(file, 'r') as f:
                    data = yaml.safe_load(f)
                
                subdomain = data["subdomain"]
                record_type = list(data["record"].keys())[0]
                record_value = data["record"][record_type]
                
                response, action = create_or_update_dns_record(subdomain, record_type, record_value)
                
                if response.status_code in [200, 201]:
                    result = response.json()
                    if result.get('success'):
                        print(f"‚úÖ {action}: {subdomain}.r-u.live ‚Üí {record_value} ({record_type})")
                        success_count += 1
                    else:
                        errors = result.get('errors', [])
                        print(f"‚ùå FAILED: {subdomain}.r-u.live - {errors}")
                        error_count += 1
                else:
                    print(f"‚ùå HTTP {response.status_code}: {subdomain}.r-u.live - {response.text}")
                    error_count += 1
                    
            except Exception as e:
                print(f"‚ùå Error processing {file}: {str(e)}")
                error_count += 1

        print(f"\nüìä DEPLOYMENT SUMMARY:")
        print(f"   ‚úÖ Success: {success_count}")
        print(f"   ‚ùå Errors: {error_count}")
        print(f"   üìÅ Total Files: {len(files)}")
        
        if error_count > 0:
            exit(1)
        
        print(f"\nüéâ All DNS records deployed successfully!")
        EOF

    - name: üí¨ Comment on PR
      if: github.event.pull_request.merged == true
      uses: actions/github-script@v7
      with:
        script: |
          const fs = require('fs');
          const yaml = require('js-yaml');
          
          // Get changed files
          const changedFiles = '${{ steps.changed-files.outputs.all_changed_files }}';
          const files = changedFiles.split(' ').filter(f => f.endsWith('.yaml'));
          
          if (files.length === 0) return;
          
          let comment = 'üéâ **DNS Records Successfully Deployed!**\n\n';
          comment += '| Subdomain | Target | Type | Status |\n';
          comment += '|-----------|--------|------|--------|\n';
          
          for (const file of files) {
            try {
              const content = fs.readFileSync(file, 'utf8');
              const data = yaml.load(content);
              const subdomain = data.subdomain;
              const recordType = Object.keys(data.record)[0];
              const target = data.record[recordType];
              
              comment += `| \`${subdomain}.r-u.live\` | \`${target}\` | ${recordType} | ‚úÖ Active |\n`;
            } catch (error) {
              console.error(`Error reading ${file}:`, error);
            }
          }
          
          comment += '\n‚ö° **Your subdomain(s) should be active within 5-10 minutes!**\n\n';
          comment += 'üîó **Next Steps:**\n';
          comment += '- Test your subdomain: `nslookup yourname.r-u.live`\n';
          comment += '- For GitHub Pages: Add custom domain in repository settings\n';
          comment += '- Enable HTTPS in your hosting platform\n\n';
          comment += '‚ùì **Need help?** Mention @anshulyadaw in a comment.';
          
          github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: comment
          });
