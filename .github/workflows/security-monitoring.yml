name: 🛡️ Security & Monitoring

on:
  schedule:
    - cron: '0 */6 * * *'  # Every 6 hours
  workflow_dispatch:

jobs:
  security-scan:
    runs-on: ubuntu-latest
    
    steps:
    - name: 📥 Checkout Repository
      uses: actions/checkout@v4

    - name: 🐍 Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'

    - name: 📦 Install Dependencies
      run: |
        pip install PyYAML requests dnspython

    - name: 🛡️ Security Scan
      env:
        CF_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
        CF_ZONE_ID: ${{ secrets.CLOUDFLARE_ZONE_ID }}
      run: |
        python << 'EOF'
        import os, yaml, requests, socket, dns.resolver, glob
        from datetime import datetime
        
        def check_malicious_ips():
            """Check for known malicious IPs"""
            malicious_indicators = []
            
            for yaml_file in glob.glob("subdomains/*.yaml"):
                try:
                    with open(yaml_file, 'r') as f:
                        data = yaml.safe_load(f)
                    
                    # Check A records for suspicious IPs
                    if 'record' in data and 'A' in data['record']:
                        ip = data['record']['A']
                        
                        # Check against common malicious ranges
                        suspicious_ranges = [
                            '0.0.0.0', '127.0.0.1', '10.0.0.',
                            '192.168.', '172.16.', '224.', '255.'
                        ]
                        
                        if any(ip.startswith(range_prefix) for range_prefix in suspicious_ranges):
                            malicious_indicators.append(f"⚠️ Suspicious IP in {yaml_file}: {ip}")
                
                except Exception as e:
                    print(f"Error checking {yaml_file}: {e}")
            
            return malicious_indicators
        
        def check_dns_health():
            """Check DNS record health"""
            health_issues = []
            
            # Check Cloudflare API connectivity
            headers = {
                "Authorization": f"Bearer {os.environ.get('CF_API_TOKEN', '')}",
                "Content-Type": "application/json"
            }
            
            try:
                response = requests.get(
                    f"https://api.cloudflare.com/client/v4/zones/{os.environ.get('CF_ZONE_ID', '')}/dns_records",
                    headers=headers,
                    timeout=10
                )
                
                if response.status_code != 200:
                    health_issues.append(f"❌ Cloudflare API error: {response.status_code}")
                else:
                    records = response.json().get('result', [])
                    print(f"✅ Cloudflare API healthy - {len(records)} DNS records found")
                    
            except Exception as e:
                health_issues.append(f"❌ Cloudflare API connection failed: {e}")
            
            return health_issues
        
        def generate_report():
            """Generate security and health report"""
            print("🛡️ Starting Security & Health Check...")
            print(f"📅 Scan time: {datetime.now().isoformat()}")
            print("=" * 50)
            
            # Security checks
            malicious = check_malicious_ips()
            if malicious:
                print("🚨 SECURITY ALERTS:")
                for alert in malicious:
                    print(f"  {alert}")
            else:
                print("✅ No security issues detected")
            
            print("\n" + "=" * 50)
            
            # Health checks
            health = check_dns_health()
            if health:
                print("🏥 HEALTH ISSUES:")
                for issue in health:
                    print(f"  {issue}")
            else:
                print("✅ All systems healthy")
            
            # Set GitHub output for notifications
            if malicious or health:
                with open(os.environ['GITHUB_ENV'], 'a') as f:
                    f.write("SECURITY_ALERTS=true\n")
                    f.write(f"ALERT_COUNT={len(malicious) + len(health)}\n")
            else:
                with open(os.environ['GITHUB_ENV'], 'a') as f:
                    f.write("SECURITY_ALERTS=false\n")
        
        generate_report()
        EOF

  monitoring:
    runs-on: ubuntu-latest
    needs: security-scan
    if: always()
    
    steps:
    - name: 📊 Generate Metrics
      run: |
        python << 'EOF'
        import glob, yaml, json
        from datetime import datetime
        
        metrics = {
            "scan_time": datetime.now().isoformat(),
            "total_subdomains": 0,
            "record_types": {"A": 0, "CNAME": 0},
            "domains_by_month": {},
            "top_owners": {}
        }
        
        for yaml_file in glob.glob("subdomains/*.yaml"):
            try:
                with open(yaml_file, 'r') as f:
                    data = yaml.safe_load(f)
                
                metrics["total_subdomains"] += 1
                
                # Count record types
                if 'record' in data:
                    for record_type in data['record']:
                        if record_type in metrics["record_types"]:
                            metrics["record_types"][record_type] += 1
                
                # Count by owner
                if 'owner' in data and 'name' in data['owner']:
                    owner = data['owner']['name']
                    metrics["top_owners"][owner] = metrics["top_owners"].get(owner, 0) + 1
                
            except Exception as e:
                print(f"Error processing {yaml_file}: {e}")
        
        print("📊 r-u.live Metrics Dashboard")
        print("=" * 40)
        print(f"📈 Total Subdomains: {metrics['total_subdomains']}")
        print(f"🅰️ A Records: {metrics['record_types']['A']}")
        print(f"🔗 CNAME Records: {metrics['record_types']['CNAME']}")
        print(f"👥 Unique Owners: {len(metrics['top_owners'])}")
        
        # Top owners
        if metrics["top_owners"]:
            sorted_owners = sorted(metrics["top_owners"].items(), key=lambda x: x[1], reverse=True)[:5]
            print("\n🏆 Top Contributors:")
            for owner, count in sorted_owners:
                print(f"  {owner}: {count} subdomain(s)")
        EOF

  notify-alerts:
    runs-on: ubuntu-latest
    needs: security-scan
    if: env.SECURITY_ALERTS == 'true'
    
    steps:
    - name: 🚨 Create Security Alert Issue
      uses: actions/github-script@v7
      with:
        script: |
          const title = `🚨 Security Alert - ${new Date().toISOString().split('T')[0]}`;
          const body = `**Automated Security Scan Alert**
          
          🕐 **Scan Time:** ${new Date().toISOString()}
          ⚠️ **Alert Count:** ${{ env.ALERT_COUNT }}
          
          **Details:**
          A scheduled security scan has detected potential issues that require attention.
          
          **Next Steps:**
          1. Review the workflow logs for detailed information
          2. Investigate flagged subdomains or configurations
          3. Take corrective action if necessary
          4. Close this issue once resolved
          
          **Workflow Run:** ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          `;
          
          // Check if similar issue already exists
          const existingIssues = await github.rest.issues.listForRepo({
            owner: context.repo.owner,
            repo: context.repo.repo,
            labels: 'security-alert',
            state: 'open'
          });
          
          if (existingIssues.data.length === 0) {
            github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: title,
              body: body,
              labels: ['security-alert', 'high-priority']
            });
          }
