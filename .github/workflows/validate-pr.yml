name: ğŸ”’ Comprehensive Validation and Security Scan

on:
  pull_request:
    types: [opened, synchronize, reopened]
    paths:
      - 'subdomains/*.yaml'
      - 'subdomains/*.yml'

jobs:
  validate-submission:
    name: ğŸ” Validate Subdomain Request
    runs-on: ubuntu-latest
    
    steps:
    - name: ğŸ“¥ Checkout Repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: ğŸ Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'

    - name: ğŸ“¦ Install Dependencies
      run: |
        pip install --upgrade pip
        pip install PyYAML jsonschema dnspython requests ipaddress tldextract whois

    - name: ğŸ” Comprehensive Validation
      run: |
        python << 'EOF'
        import os, yaml, json, re, ipaddress, socket, requests
        from pathlib import Path
        import subprocess
        
        # Get changed files
        result = subprocess.run(['git', 'diff', '--name-only', 'origin/main', 'HEAD'], 
                              capture_output=True, text=True)
        changed_files = result.stdout.strip().split('\n') if result.stdout.strip() else []
        
        subdomain_files = [f for f in changed_files if f.startswith('subdomains/') and f.endswith(('.yaml', '.yml'))]
        
        if not subdomain_files:
            print("âœ… No subdomain files to validate")
            exit(0)
        
        print(f"ğŸ” Validating {len(subdomain_files)} subdomain file(s)")
        
        errors = []
        warnings = []
        
        for file_path in subdomain_files:
            if not os.path.exists(file_path):
                continue
                
            print(f"\nğŸ“‹ Validating: {file_path}")
            
            try:
                with open(file_path, 'r') as f:
                    data = yaml.safe_load(f)
            except Exception as e:
                errors.append(f"{file_path}: Invalid YAML format: {e}")
                continue
            
            # Schema validation
            required_fields = ['subdomain', 'owner', 'record']
            for field in required_fields:
                if field not in data:
                    errors.append(f"{file_path}: Missing required field: {field}")
            
            if 'owner' in data:
                if 'name' not in data['owner'] or 'email' not in data['owner']:
                    errors.append(f"{file_path}: Owner must have name and email")
            
            if 'record' in data:
                if not any(key in data['record'] for key in ['A', 'AAAA', 'CNAME']):
                    errors.append(f"{file_path}: Must have at least one DNS record (A, AAAA, or CNAME)")
            
            # Subdomain validation
            if 'subdomain' in data:
                subdomain = data['subdomain']
                
                # Format validation
                if not re.match(r'^[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?$', subdomain):
                    errors.append(f"{file_path}: Invalid subdomain format")
                
                # Reserved names
                reserved = ["www", "mail", "ftp", "admin", "api", "app", "blog", "shop", 
                           "store", "test", "dev", "staging", "prod", "production", "beta",
                           "alpha", "cdn", "static", "assets", "help", "support", "docs"]
                if subdomain.lower() in reserved:
                    errors.append(f"{file_path}: Subdomain '{subdomain}' is reserved")
                
                # Check filename matches subdomain
                expected_filename = f"subdomains/{subdomain}.yaml"
                if file_path != expected_filename and file_path != f"subdomains/{subdomain}.yml":
                    errors.append(f"{file_path}: Filename must match subdomain name")
            
            # DNS record validation
            if 'record' in data:
                records = data['record']
                
                for record_type, target in records.items():
                    if record_type == 'A':
                        if isinstance(target, list):
                            for ip in target:
                                try:
                                    ipaddr = ipaddress.IPv4Address(ip)
                                    if ipaddr.is_private or ipaddr.is_loopback or ipaddr.is_reserved:
                                        warnings.append(f"{file_path}: Private/reserved IP detected: {ip}")
                                except ipaddress.AddressValueError:
                                    errors.append(f"{file_path}: Invalid IPv4 address: {ip}")
                        else:
                            try:
                                ipaddr = ipaddress.IPv4Address(target)
                                if ipaddr.is_private or ipaddr.is_loopback or ipaddr.is_reserved:
                                    warnings.append(f"{file_path}: Private/reserved IP detected: {target}")
                            except ipaddress.AddressValueError:
                                errors.append(f"{file_path}: Invalid IPv4 address: {target}")
                    
                    elif record_type == 'AAAA':
                        targets = target if isinstance(target, list) else [target]
                        for ipv6 in targets:
                            try:
                                ipaddr = ipaddress.IPv6Address(ipv6)
                                if ipaddr.is_private or ipaddr.is_loopback or ipaddr.is_reserved:
                                    warnings.append(f"{file_path}: Private/reserved IPv6 detected: {ipv6}")
                            except ipaddress.AddressValueError:
                                errors.append(f"{file_path}: Invalid IPv6 address: {ipv6}")
                    
                    elif record_type == 'CNAME':
                        if not re.match(r'^(?=.{1,253}$)(?:[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,63}$', target):
                            errors.append(f"{file_path}: Invalid CNAME target: {target}")
                        
                        # Check if domain resolves
                        try:
                            socket.gethostbyname(target)
                        except socket.gaierror:
                            warnings.append(f"{file_path}: CNAME target may not resolve: {target}")
            
            print(f"âœ… Validation completed for {file_path}")
        
        # Output results
        if errors:
            print(f"\nâŒ Found {len(errors)} error(s):")
            for error in errors:
                print(f"  - {error}")
            
            # Save errors for PR comment
            with open('validation_errors.txt', 'w') as f:
                f.write('\n'.join(errors))
            
            exit(1)
        
        if warnings:
            print(f"\nâš ï¸ Found {len(warnings)} warning(s):")
            for warning in warnings:
                print(f"  - {warning}")
            
            # Save warnings for PR comment
            with open('validation_warnings.txt', 'w') as f:
                f.write('\n'.join(warnings))
        
        print(f"\nâœ… All validations passed!")
        EOF

    - name: ğŸ”’ Security Scan
      run: |
        python << 'EOF'
        import os, yaml, re, requests
        from pathlib import Path
        import subprocess
        
        # Get changed files
        result = subprocess.run(['git', 'diff', '--name-only', 'origin/main', 'HEAD'], 
                              capture_output=True, text=True)
        changed_files = result.stdout.strip().split('\n') if result.stdout.strip() else []
        
        subdomain_files = [f for f in changed_files if f.startswith('subdomains/') and f.endswith(('.yaml', '.yml'))]
        
        security_issues = []
        
        for file_path in subdomain_files:
            if not os.path.exists(file_path):
                continue
                
            print(f"ğŸ”’ Security scanning: {file_path}")
            
            try:
                with open(file_path, 'r') as f:
                    content = f.read()
                    data = yaml.safe_load(content)
            except:
                continue
            
            # Check for malicious patterns
            malicious_patterns = [
                r'<script.*?>.*?</script>',
                r'javascript:',
                r'data:text/html',
                r'vbscript:',
                r'onload=',
                r'onerror=',
                r'\$\{.*?\}',
                r'<%.*?%>',
                r'{{.*?}}',
            ]
            
            for pattern in malicious_patterns:
                if re.search(pattern, content, re.IGNORECASE):
                    security_issues.append(f"{file_path}: Potential malicious content detected")
                    break
            
            # Check email domains against known temporary email services
            if 'owner' in data and 'email' in data['owner']:
                email = data['owner']['email']
                domain = email.split('@')[1].lower()
                
                temp_domains = [
                    '10minutemail.com', 'guerrillamail.com', 'tempmail.org',
                    'throwaway.email', 'mailinator.com', 'temp-mail.org'
                ]
                
                if domain in temp_domains:
                    security_issues.append(f"{file_path}: Temporary email service detected: {domain}")
            
            # Check for suspicious repository URLs
            if 'owner' in data and 'repo' in data['owner']:
                repo_url = data['owner']['repo']
                suspicious_repo_patterns = [
                    r'bit\.ly/',
                    r'tinyurl\.com/',
                    r'short\.link/',
                    r'[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+',  # IP addresses
                ]
                
                for pattern in suspicious_repo_patterns:
                    if re.search(pattern, repo_url):
                        security_issues.append(f"{file_path}: Suspicious repository URL: {repo_url}")
                        break
        
        if security_issues:
            print(f"\nğŸš¨ Found {len(security_issues)} security issue(s):")
            for issue in security_issues:
                print(f"  - {issue}")
            
            with open('security_issues.txt', 'w') as f:
                f.write('\n'.join(security_issues))
            
            exit(1)
        
        print("âœ… Security scan passed!")
        EOF

    - name: ğŸ“Š Generate Validation Report
      if: always()
      run: |
        echo "# ğŸ” Validation Report" > validation_report.md
        echo "" >> validation_report.md
        echo "## Files Validated" >> validation_report.md
        
        git diff --name-only origin/main HEAD | grep -E "subdomains/.*\.(yaml|yml)$" | while read file; do
          echo "- \`$file\`" >> validation_report.md
        done
        
        echo "" >> validation_report.md
        
        if [ -f validation_errors.txt ]; then
          echo "## âŒ Validation Errors" >> validation_report.md
          echo "" >> validation_report.md
          while IFS= read -r line; do
            echo "- $line" >> validation_report.md
          done < validation_errors.txt
          echo "" >> validation_report.md
        fi
        
        if [ -f validation_warnings.txt ]; then
          echo "## âš ï¸ Warnings" >> validation_report.md
          echo "" >> validation_report.md
          while IFS= read -r line; do
            echo "- $line" >> validation_report.md
          done < validation_warnings.txt
          echo "" >> validation_report.md
        fi
        
        if [ -f security_issues.txt ]; then
          echo "## ğŸš¨ Security Issues" >> validation_report.md
          echo "" >> validation_report.md
          while IFS= read -r line; do
            echo "- $line" >> validation_report.md
          done < security_issues.txt
          echo "" >> validation_report.md
        fi
        
        if [ ! -f validation_errors.txt ] && [ ! -f security_issues.txt ]; then
          echo "## âœ… All Checks Passed" >> validation_report.md
          echo "" >> validation_report.md
          echo "Your subdomain request has passed all automated validation and security checks!" >> validation_report.md
        fi

    - name: ğŸ“ Comment on PR
      if: always()
      uses: actions/github-script@v7
      with:
        script: |
          const fs = require('fs');
          
          try {
            const report = fs.readFileSync('validation_report.md', 'utf8');
            
            // Check if validation failed
            const hasErrors = fs.existsSync('validation_errors.txt');
            const hasSecurityIssues = fs.existsSync('security_issues.txt');
            
            let comment = report;
            
            if (hasErrors || hasSecurityIssues) {
              comment += '\n\n---\n\n';
              comment += 'âŒ **This PR requires attention before it can be merged.**\n\n';
              comment += 'Please address the issues listed above and push new commits to update this PR.';
              
              // Add label
              await github.rest.issues.addLabels({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                labels: ['validation-failed', 'needs-changes']
              });
            } else {
              comment += '\n\n---\n\n';
              comment += 'âœ… **This PR is ready for manual review!**\n\n';
              comment += 'All automated checks have passed. A maintainer will review this request shortly.';
              
              // Add label
              await github.rest.issues.addLabels({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                labels: ['validation-passed', 'awaiting-review']
              });
            }
            
            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });
          } catch (error) {
            console.log('No validation report generated');
          }

  dns-validation:
    name: ğŸŒ DNS Connectivity Test
    runs-on: ubuntu-latest
    needs: validate-submission
    if: success()
    
    steps:
    - name: ğŸ“¥ Checkout Repository
      uses: actions/checkout@v4

    - name: ğŸŒ Test DNS Resolution
      run: |
        python << 'EOF'
        import subprocess, yaml, socket, os
        from pathlib import Path
        
        # Get changed files
        result = subprocess.run(['git', 'diff', '--name-only', 'origin/main', 'HEAD'], 
                              capture_output=True, text=True)
        changed_files = result.stdout.strip().split('\n') if result.stdout.strip() else []
        
        subdomain_files = [f for f in changed_files if f.startswith('subdomains/') and f.endswith(('.yaml', '.yml'))]
        
        results = []
        
        for file_path in subdomain_files:
            if not os.path.exists(file_path):
                continue
                
            try:
                with open(file_path, 'r') as f:
                    data = yaml.safe_load(f)
            except:
                continue
            
            if 'record' not in data:
                continue
            
            print(f"ğŸŒ Testing DNS for: {file_path}")
            
            for record_type, target in data['record'].items():
                if record_type == 'A':
                    targets = target if isinstance(target, list) else [target]
                    for ip in targets:
                        try:
                            # Basic connectivity test
                            socket.create_connection((ip, 80), timeout=5)
                            results.append(f"âœ… {ip}: HTTP port accessible")
                        except:
                            try:
                                socket.create_connection((ip, 443), timeout=5)
                                results.append(f"âœ… {ip}: HTTPS port accessible")
                            except:
                                results.append(f"âš ï¸ {ip}: No standard web ports accessible")
                
                elif record_type == 'CNAME':
                    try:
                        socket.gethostbyname(target)
                        results.append(f"âœ… {target}: Domain resolves")
                        
                        # Test connectivity
                        try:
                            socket.create_connection((target, 443), timeout=5)
                            results.append(f"âœ… {target}: HTTPS accessible")
                        except:
                            try:
                                socket.create_connection((target, 80), timeout=5)
                                results.append(f"âœ… {target}: HTTP accessible")
                            except:
                                results.append(f"âš ï¸ {target}: Domain resolves but no web ports accessible")
                    except:
                        results.append(f"âŒ {target}: Domain does not resolve")
        
        print("\nğŸŒ DNS Test Results:")
        for result in results:
            print(f"  {result}")
        EOF
